import sys
from PySide6.QtWidgets import QApplication, QSizePolicy, QSpacerItem, QMainWindow, QGridLayout, QPushButton, QMessageBox, QWidget, QLabel, QVBoxLayout, QHBoxLayout, QColorDialog, QDialog, QComboBox
from PySide6.QtCore import QTimer, Qt
from PySide6.QtGui import QPixmap, QColor, QFont
#add timer, reset score should be red button
player1 = 0
player2 = 0
player1_color = "#FF0000"
player2_color = "#FFFF00"

class ColorDialog(QColorDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Choose your color")


class ColorSelectWidget(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)

        layout = QVBoxLayout()

        player1_color_button = QPushButton("Select Player 1 Color", self)
        player1_color_button.clicked.connect(self.select_player1_color)
        layout.addWidget(player1_color_button)

        player2_color_button = QPushButton("Select Player 2 Color", self)
        player2_color_button.clicked.connect(self.select_player2_color)
        layout.addWidget(player2_color_button)
        
        board_size_label = QLabel("Select Board Size:")
        layout.addWidget(board_size_label)

        self.board_size_combo = QComboBox(self)
        self.board_size_combo.addItem("6x7")  # Default
        self.board_size_combo.addItem("8x9")
        self.board_size_combo.addItem("10x12")
        layout.addWidget(self.board_size_combo)
        
        confirm_button = QPushButton("Confirm Selection", self)
        confirm_button.clicked.connect(self.confirm_selection)
        layout.addWidget(confirm_button)


        self.setLayout(layout)

        # Initialize selected size
        self.selected_size = self.get_selected_size()

        # Connect combo box signal to update selected size
        self.board_size_combo.currentIndexChanged.connect(self.update_selected_size)

    def select_player1_color(self):
        global player1_color
        color_dialog = ColorDialog(self)
        if color_dialog.exec_() == ColorDialog.Accepted:
            player1_color = color_dialog.selectedColor().name()

    def select_player2_color(self):
        global player2_color
        color_dialog = ColorDialog(self)
        if color_dialog.exec_() == ColorDialog.Accepted:
            player2_color = color_dialog.selectedColor().name()
    
    def get_selected_size(self):
        return tuple(map(int, self.board_size_combo.currentText().split('x')))

    def update_selected_size(self):
        self.selected_size = self.get_selected_size()
    
    def confirm_selection(self):
        # Add any actions you want to perform after confirmation
        print("Confirmed Selection")
        print("Selected Size:", self.selected_size)
        self.accept()
        
class MenuPage(QMainWindow):
    def __init__(self):
        super().__init__()

        self.init_ui()
        
    def init_ui(self):
        central_widget = QWidget()
        central_widget.setStyleSheet("background-color: lightgrey;")
        self.setCentralWidget(central_widget)
        self.color_select_widget = ColorSelectWidget(self)
        
        # Use a QVBoxLayout for the main layout
        main_layout = QVBoxLayout()
        
        connect_four_label = QLabel('<font size="30" color="black"><b>Connect</b></font><font size ="30" color="red"><b>Four</b></font>', self)
        connect_four_label.setAlignment(Qt.AlignCenter)  # Center the label
        main_layout.addWidget(connect_four_label)
        # Create a horizontal layout for the image and buttons
        image_button_layout = QHBoxLayout()
    
        board_img = QLabel(self)
        image = QPixmap("images/board.png")
        board_img.setPixmap(image)
        board_img.setAlignment(Qt.AlignCenter)  # Center the image
        image_button_layout.addWidget(board_img, alignment=Qt.AlignRight)

        # Create a vertical layout for buttons
        button_layout = QVBoxLayout()
        
        #font = QFont("Press Start 2P", 24, QFont.Bold)
        start_game_button = QPushButton("Play", self)
        start_game_button.setFixedSize(200, 60)
        start_game_button.setFont(QFont("Press Start 2P", 24, QFont.Bold))
        #start_game_button.setStyleSheet("color: white; background-color: blue; border-style: outset; border-width: 2px; border-radius: 10px; border-color: beige; font: bold 14px; min-width: 3em; padding: 6px; min-height: 2em")
        start_game_button.setStyleSheet(
            "QPushButton {background-color: blue; color: white; border-radius: 10px; padding: 10px; border-width: 2px; border-color: black; border: 1px solid black;}"
            "QPushButton:hover {background-color: darkblue;}"
            "QPushButton:pressed {background-color: blue;}"
        )
        start_game_button.clicked.connect(self.start_game)
        button_layout.addWidget(start_game_button, alignment=Qt.AlignRight)

        #restart_game_button = QPushButton("Restart Game", self)
        #restart_game_button.setStyleSheet("color: white; background-color: blue; border-style: outset; border-width: 2px; border-radius: 10px; border-color: beige; font: bold 14px; min-width: 3em; padding: 6px;min-height: 2em")
        #restart_game_button.setStyleSheet(
        #    "QPushButton {background-color: #f44336; color: white; border-radius: 10px; padding: 10px; border-width: 2px; border-color: black}"
        #    "QPushButton:hover {background-color: #d32f2f;}"
        #    "QPushButton:pressed {background-color: #b71c1c;}"
        #
        #)
        #restart_game_button.clicked.connect(self.reset_game)
        #button_layout.addWidget(restart_game_button)

        reset_score_button = QPushButton("Reset", self)
        reset_score_button.setStyleSheet(
            "QPushButton {background-color: #f44336; color: white; border-radius: 10px; padding: 10px; border-width: 2px; border-color: black; border: 1px solid black;}"
            "QPushButton:hover {background-color: #d32f2f;}"
            "QPushButton:pressed {background-color: #b71c1c;}"
        
        )
        reset_score_button.clicked.connect(self.reset_score)
        reset_score_button.setFixedSize(200, 40)
        reset_score_button.setFont(QFont("Press Start 2P", 18, QFont.Bold))
        button_layout.addWidget(reset_score_button, alignment=Qt.AlignRight)
        
        settings_buttons = QPushButton("Settings", self)
        settings_buttons.setFixedSize(100, 35)
        settings_buttons.setFont(QFont("Press Start 2P", 12, QFont.Bold))
        settings_buttons.setStyleSheet(
            "QPushButton {background-color: darkgrey; color: white; border-radius: 10px; padding: 10px; border: 1px solid black;}"
            "QPushButton:hover {background-color: grey;}"
            "QPushButton:pressed {background-color: darkgrey;}"
        )
        settings_buttons.clicked.connect(self.settings)

        button_layout.addWidget(settings_buttons, alignment=Qt.AlignRight)

        # Add the button layout to the image and button layout
        image_button_layout.addLayout(button_layout)

        # Add the image and button layout to the main layout
        main_layout.addLayout(image_button_layout)


        central_widget.setLayout(main_layout)
        self.resize(560, 400)

    def start_game(self):
        # Check if there is a saved state
        if hasattr(self, 'connect_four_game_state'):
            saved_state = self.connect_four_game_state
            delattr(self, 'connect_four_game_state')  # Clear the saved state
        else:
            saved_state = None

        selected_size = self.color_select_widget.selected_size  # Retrieve selected size
        self.connect_four_game = ConnectFourGUI(rows=selected_size[0], columns=selected_size[1], menu_page=self)
        print(f'{self.connect_four_game.load_scores()}')
        print(f'{self.connect_four_game.player1}{self.connect_four_game.player2}')
        self.connect_four_game.player1, self.connect_four_game.player2 = self.connect_four_game.load_scores()
        print(f'{self.connect_four_game.player1}{self.connect_four_game.player2}')
        if saved_state:
            self.connect_four_game.load_game(saved_state)
        self.connect_four_game.show()
        self.hide()
    
    def reset_score(self): # not reseting scores
        global player1_color, player2_color, player1, player2
        player1_color = "#FF0000"
        player2_color = "#FFFF00"
        self.color_select_widget.board_size_combo.setCurrentIndex(0)
        player1 = 0
        player2 = 0
        
        #self.save_scores(self.connect_four_game.player1, self.connect_four_game.player2)
    def settings(self):
        self.color_select_widget.show()

    
            
            

class ConnectFourGUI(QMainWindow):
    #player1 = 0
    #player2 = 0
    def __init__(self, rows, columns, menu_page):
        global player1, player2
        super().__init__()
        self.menu_page = menu_page
        self.player1 = 0
        self.player2 = 0
        self.player = 0
        self.rows = rows
        self.winning_positions = []
        self.columns = columns
        self.board = [[-1] * self.columns for _ in range(self.rows)]

        self.init_ui()

    def init_ui(self):
        global player1, player2
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        central_widget.setStyleSheet("background-color: darkblue;")
        self.player1_score = QLabel(f"Player 1 score: {player1}")
        self.player1_score.setStyleSheet("QLabel {color: lightgrey}")
        self.player2_score = QLabel(f"Player 2 score: {player2}")
        self.player2_score.setStyleSheet("QLabel {color: lightgrey}")
        main_layout = QVBoxLayout()
        self.winning_title = QLabel(f"", self)
        self.winning_title.setAlignment(Qt.AlignCenter)
        self.current_player_label = QLabel("Current: Player 1", self)
        self.current_player_label.setStyleSheet("QLabel {color: lightgrey}")
        main_layout.addWidget(self.current_player_label)
        main_layout.addWidget(self.player1_score)
        main_layout.addWidget(self.player2_score)
        
        winning_layout = QHBoxLayout()
        winning_layout.addWidget(self.winning_title)
        layout = QGridLayout()
        
        home_menu_button = QPushButton("🚪", self)#𓉞
        home_menu_button.setStyleSheet(
            "QPushButton {background-color: darkgrey; color: white; border-width: 2px; border-radius: 5px; padding: 5px; width: 30px;}"
            "QPushButton:hover {background-color: grey;}"
            "QPushButton:pressed {background-color: darkgrey;}"
        )
        home_menu_button.setFixedSize(27, 35)
        home_menu_button.clicked.connect(self.main_menu)
        winning_layout.addWidget(home_menu_button)
        
        

        self.buttons = []
        for row in range(self.rows):
            for col in range(self.columns):
                button = QPushButton()

                button.clicked.connect(lambda row=row, col=col: self.handle_button_click(row, col))
                self.buttons.append(button)
                layout.addWidget(button, row, col)
                self.style_button(button)
                #button.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        
        main_layout.addLayout(winning_layout)


        main_layout.addLayout(layout)
        central_widget.setLayout(main_layout)
    
    def main_menu(self):
        self.save_game()
        self.hide()
        self.menu_page.show()
        
    def style_button(self, button):
        global player1_color, player2_color
        button.setFixedSize(50, 50)  # Set a fixed size for the button
        player_color = player1_color if self.player == 0 else player2_color
        button.setStyleSheet("""
            QPushButton {
                background-color: white;
                border: 2px solid black;
                border-radius: 25px; /* Half of the button size for a circular shape */
            }
            QPushButton:hover {
                background-color: lightgrey;
            }
        """)
        
        
    def load_scores(self):
        global player1, player2
        return player1, player2
    def check_legal_move(self, column):
        return 0 <= column < self.columns and self.board[0][column] == -1
    # ... (rest of your ConnectFourGUI class)
    def handle_button_click(self, row, col):
        # Add logic to handle button click
        # such as update the board and redraw the GUI
        if not self.check_winner():
            print(f"Button in row {row + 1}, column {col + 1} clicked")
            if self.check_legal_move(col):
                self.drop_piece(self.player, col)
                if self.check_winner():
                    self.display_winner(self.player)
                    if self.player == 0:
                        self.winning_title.setText('Player 1 wins!')
                    else:
                        self.winning_title.setText('Player 2 wins!')
                    QTimer.singleShot(1000, self.reset_game)
                    
                #self.reset_game()
                else:
                    #if you are checking wins, change 1 to 0. For functioning game, change to self.player + 1
                    self.player = (self.player + 1) % 2
                    if self.player == 1:
                        self.current_player_label.setText("Current: Player 2")
                    else:
                        self.current_player_label.setText("Current: Player 1")
            else:
                QMessageBox.information(self, "", f"Player {self.player+1} made an illegal move. Try again", QMessageBox.Ok)
        if self.is_board_full():
            QMessageBox.information(self, "", f"Players tied", QMessageBox.Ok)
            self.reset_game()

    def check_winner(self):

        for i in range(self.rows):
            for j in range(self.columns):
                # Check vertical
                if i + 3 < self.rows and self.board[i][j] == self.board[i + 1][j] == self.board[i + 2][j] == self.board[i + 3][j] != -1:
                    self.winning_positions = [(i, j), (i + 1, j), (i + 2, j), (i + 3, j)]
                    print(f"Player {self.board[i][j]} wins vertically!")
                    self.update_button_visuals(i, j)
                    QMessageBox.information(self, "Winner!", f"Player {self.player+1} wins vertically!", QMessageBox.Ok) #Message boxes not displaying correct player
                    
                    if self.player == 1:
                        pass
                    return True

                # Check horizontal
                if j + 3 < self.columns and self.board[i][j] == self.board[i][j + 1] == self.board[i][j + 2] == self.board[i][j + 3] != -1:
                    self.winning_positions = [(i, j), (i, j + 1), (i, j + 2), (i, j + 3)]
                    print(f"Player {self.board[i][j]} wins horizontally!")
                    self.update_button_visuals(i, j)
                    QMessageBox.information(self, "Winner!", f"Player {self.player+1} wins horizontally!", QMessageBox.Ok)
                    return True

                # Check diagonal
                if i + 3 < self.rows and j + 3 < self.columns and self.board[i][j] == self.board[i + 1][j + 1] == self.board[i + 2][j + 2] == self.board[i + 3][j + 3] != -1:
                    self.winning_positions = [(i, j), (i + 1, j + 1), (i + 2, j + 2), (i + 3, j + 3)]
                    self.update_button_visuals(i, j)
                    QMessageBox.information(self, "Winner!", f"Player {self.player+1} wins horizontally!", QMessageBox.Ok)
                    return True
                if i - 3 >= 0 and j + 3 < self.columns and self.board[i][j] == self.board[i - 1][j + 1] == self.board[i - 2][j + 2] == self.board[i - 3][j + 3] != -1:
                    self.winning_positions = [(i, j), (i - 1, j + 1), (i - 2, j + 2), (i - 3, j + 3)]
                    self.update_button_visuals(i, j)
                    QMessageBox.information(self, "Winner!", f"Player {self.player+1} wins diagonally!", QMessageBox.Ok)
                    return True
           
        
    def show_winner(self):
        QMessageBox.information(self, "Winner!", f"The winner is {self.board[i][j]}!", QMessageBox.Ok)
        
        # Start a new game
        self.new_game()
        
    def drop_piece(self, player, column):
        for row in range(self.rows -1, -1, -1):
            if self.board[row][column] == -1:
                self.board[row][column] = player
                self.update_button_visuals(row, column)
                break

    def update_button_visuals(self, row, col):
        global player1_color, player2_color
        player_color = player1_color if self.player == 0 else player2_color
        button = self.buttons[row * self.columns + col]
        self.buttons[row * self.columns + col].setStyleSheet(f"""
            QPushButton {{
                background-color: {player_color};
                border: 2px solid black;
                border-radius: 25px; /* Half of the button size for a circular shape */
            }}
        """)
        
        if (row, col) in self.winning_positions:
             print("hi")
             for index in self.winning_positions:
                 row, col = index[0], index[1]
                 self.buttons[row * self.columns + col].setStyleSheet(f"""
                 QPushButton {{
                     background-color: {player_color};
                     border: 3px solid gold;
                     border-radius: 25px; /* Half of the button size for a circular shape */
                 }}
            """)
        self.winning_positions = []
        
    def is_board_full(self):
        for row in self.board:
            if -1 in row:
                return False
        return True

    def player_counter(self):
        pass
       
    def display_winner(self, player):
        global player1, player2
        # Disable all buttons
        if player == 0:
            player1 += 1
        else:
            player2 += 1
        
        
        self.player1_score.setText(f"Player 1 score: {player1}")
        self.player2_score.setText(f"Player 2 score: {player2}")
        #for button in self.buttons:
            #button.setEnabled(False)

        # Display a message indicating the winner
        print(f"Player {player} wins!")
        

    def reset_game(self):
        #self.menu_page.show()
        #self.hide()
        self.rows, self.columns = self.get_selected_board_size()
        self.board = [[-1] * self.columns for _ in range(self.rows)]
        for button in self.buttons:
            button.setEnabled(True)
            self.style_button(button)
        self.winning_title.setText("")
        print("Reset")
        #self.player = 0
    
    def get_selected_board_size(self):
        selected_text = self.menu_page.color_select_widget.board_size_combo.currentText()
        self.rows, self.columns = int(self.rows), int(self.columns)
        rows, columns = map(int, selected_text.split('x'))
        return rows, columns
        
    def update_game_state(self, saved_state):
        global player1, player2
        """
        Update the game state based on the loaded state.
        """
        player1, player2, self.player, self.rows, self.columns, self.board = saved_state

        # Update the visual representation of the board
        for row in range(self.rows):
            for col in range(self.columns):
                self.update_button_visuals(row, col)

        # Update other UI elements if needed
        if self.player == 0:
            self.current_player_label.setText("Current: Player 1")
        else:
            self.current_player_label.setText("Current: Player 2")
        self.player1_score.setText(f"Player 1 score: {player1}")
        self.player2_score.setText(f"Player 2 score: {player2}")
        self.winning_title.setText("")  # Clear any winning title

    def load_game(self, saved_state):
        """
        Load the game state from a saved state.
        """
        self.update_game_state(saved_state)
        print(self.board)


    def save_game(self):
        global player1, player2
        """
        Save the current game state.
        """
        print(f"Saving {self.board}")
        return [player1, player2, self.player, self.rows, self.columns, self.board]
        
if __name__ == "__main__":
    app = QApplication(sys.argv)
    menu = MenuPage()
    menu.show()
    sys.exit(app.exec())
